## NLFT/QSP solver

This Python package numerically computes the inverse Non-Linear Fourier Transform and Generalized Quantum Signal Processing phase factors using techniques from recent papers:

- Michel Alexis, Gevorg Mnatsakanyan, and Christoph Thiele. *Quantum signal processing
and nonlinear Fourier analysis*. [Revista Matemática Complutense 37, 655–694](https://dx.doi.org/10.1007/s13163-024-00494-5) (2024)

- Michel Alexis, Lin Lin, Gevorg Mnatsakanyan, Christoph Thiele, and Jiasu Wang. *Infinite
quantum signal processing for arbitrary Szegö functions*, [arXiv:2407.05634](https://arxiv.org/abs/2407.05634)

- Hongkang Ni and Lexing Ying. *Fast Phase Factor Finding for Quantum Signal Processing* (2024), [arXiv:2410.06409](https://arxiv.org/abs/2410.06409).

- Lorenzo Laneve. *Generalized Quantum Signal Processing and Non-Linear Fourier Transform are equivalent*, [arXiv:2503.03026](https://arxiv.org/abs/2503.03026).

- Hongkang Ni, Rahul Sarkar, Lexing Ying, Lin Lin. *Inverse nonlinear fast Fourier transform on SU(2) with applications to quantum signal processing*, [arXiv:2505.12615](https://arxiv.org/abs/2505.12615).



## How to use the package

There are three main classes in this package.

- The `Polynomial` class in `poly.py` lets you define and manipulate general Laurent or analytic polynomials.

- The `NonLinearFourierSequence` class in `nlft.py` defines a general compactly supported sequence of complex numbers, whose `transform()` method will return two `Polynomial` objects corresponding to the image $(a, b)$ of the sequence through the NLFT.

- The `PhaseFactors` class in `qsp.py` defines a QSP protocol, along with modes that correspond to different variants of QSP, and a method `polynomials()` which returns the tuple $(P, Q)$ of polynomials generated by the QSP protocol, as `Polynomial` objects.

Here we list the main functions of this package.

### Inverse NLFT solvers

- `solvers.weiss.complete(b: Polynomial) -> Polynomial` \
Returns the unique outer complementary polynomial to $b$ such that $(a, b) \in \mathbf{H}$, the image of the NLFT.

- `solvers.weiss.ratio(b: Polynomial) -> Polynomial, Polynomial`\
Same as the above, but it returns $a$, along with a polynomial $c$ which is the Fourier approximation of $b/a$.

- `solvers.riemann_hilbert.inlft(b: Polynomial, c: Polynomial) -> NonLinearFourierSequence`\
Returns the pre-image of $(a, b)$ with the plain Riemann-Hilbert algorithm, given $b$ and the Fourier approximation $c$ to $b/a$. $\mathcal{O}(n^4)$

- `solvers.riemann_hilbert.inlft_hc(b: Polynomial, c: Polynomial) -> NonLinearFourierSequence`\
Same as above, but using the Half-Cholesky method. $\mathcal{O}(n^2)$

- `solvers.inlfft.inlft(a: Polynomial, b: Polynomial) -> NonLinearFourierSequence`
Computes the inverse NLFT of $(a, b)$ using the Inverse Non-Linear Fast Fourier Transform algorithm. $\mathcal{O}(n \log^2 n)$

### QSP solvers

- `qsp.gqsp_solve(P: Polynomial) -> GQSPPhaseFactors`\
Computes the GQSP phase factors implementing $(P, Q)$, for a complementary $Q$ computed with Weiss' algorithm.

- `qsp.xqsp_solve(P: Polynomial) -> XQSPPhaseFactors`\
Same as above, but for analytic $X$-constrained QSP.

- `qsp.xqsp_solve_laurent(P: Polynomial) -> XQSPPhaseFactors`\
Same as above, but for Laurent $X$-constrained QSP.

- `qsp.yqsp_solve(P: Polynomial) -> YQSPPhaseFactors`\
Same as above, but for analytic $Y$-constrained QSP.

- `qsp.yqsp_solve_laurent(P: Polynomial) -> YQSPPhaseFactors`\
Same as above, but for Laurent $Y$-constrained QSP.

- `qsp.chebqsp_solve(c: list[generic_complex] | ChebyshevTExpansion) -> ChebyshevQSPPhaseFactors`\
Computes the phase factors for a Chebyshev QSP protocol (Theorem 9 of [arXiv:2105.02859](https://arxiv.org/abs/2105.02859)), given the coefficients of $P(x) = \sum_{k = 0}^n c_k T_k(x)$.
